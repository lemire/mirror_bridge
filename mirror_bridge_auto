#!/bin/bash
# Mirror Bridge Auto - Auto-discover and bind all classes in a directory
# Usage: mirror_bridge_auto <src_dir> --module <name> [options]

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default configuration
OUTPUT_DIR="build"
MODULE_NAME=""
SRC_DIR=""
VERBOSE=0
KEEP_GENERATED=0
USE_PCH=""
PCH_PATH=""
FORCE_REBUILD=0

# Help message
show_help() {
    cat << EOF
Mirror Bridge Auto - Auto-discover and bind classes from directory

Usage: mirror_bridge_auto <src_dir> --module <name> [options]

Options:
  --module NAME           Python module name (required)
  -o, --output-dir DIR    Output directory for .so file (default: build/)
  -k, --keep-generated    Keep generated binding .cpp file
  -v, --verbose           Show compilation output
  --use-pch [PATH]        Use precompiled header (optional path to .gch file)
  -f, --force             Force rebuild even if sources haven't changed
  -h, --help              Show this help message

Change Detection:
  By default, mirror_bridge_auto tracks source file changes and only
  recompiles when header files have been modified since the last build.
  Use --force to bypass this check and always rebuild.

Auto-Discovery:
  Scans all .hpp/.h files in src_dir and automatically binds all
  struct/class definitions found.

  Opt-out: Add comment "MIRROR_BRIDGE_SKIP" before class:
    // MIRROR_BRIDGE_SKIP
    struct InternalClass { ... };

Examples:
  # Basic usage
  mirror_bridge_auto src/ --module my_module

  # With precompiled header (3-6x faster compilation!)
  mirror_bridge_auto src/ --module my_module --use-pch

  # With custom PCH path
  mirror_bridge_auto src/ --module my_module --use-pch build/pch.gch

This generates: build/my_module.so containing ALL classes from src/

Performance:
  Without PCH: ~500-1700ms compilation
  With PCH:    ~200-250ms compilation (3-6x faster!)

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        --module)
            MODULE_NAME="$2"
            shift 2
            ;;
        -o|--output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -k|--keep-generated)
            KEEP_GENERATED=1
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        --use-pch)
            USE_PCH="1"
            # Check if next arg is a path or another option
            if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
                PCH_PATH="$2"
                shift 2
            else
                # Auto-detect PCH in common locations
                PCH_PATH="auto"
                shift
            fi
            ;;
        -f|--force)
            FORCE_REBUILD=1
            shift
            ;;
        -*)
            echo -e "${RED}Error: Unknown option $1${NC}"
            show_help
            exit 1
            ;;
        *)
            if [ -z "$SRC_DIR" ]; then
                SRC_DIR="$1"
            else
                echo -e "${RED}Error: Multiple source directories specified${NC}"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate input
if [ -z "$SRC_DIR" ]; then
    echo -e "${RED}Error: No source directory specified${NC}"
    show_help
    exit 1
fi

if [ -z "$MODULE_NAME" ]; then
    echo -e "${RED}Error: No module name specified (use --module)${NC}"
    show_help
    exit 1
fi

if [ ! -d "$SRC_DIR" ]; then
    echo -e "${RED}Error: Directory not found: $SRC_DIR${NC}"
    exit 1
fi

# Get absolute paths
SRC_DIR=$(realpath "$SRC_DIR")
OUTPUT_DIR=$(realpath "$OUTPUT_DIR")

mkdir -p "$OUTPUT_DIR"

echo -e "${BLUE}Mirror Bridge Auto-Discovery${NC}"
echo -e "${BLUE}============================${NC}"
echo ""
echo -e "Source directory: ${YELLOW}$SRC_DIR${NC}"
echo -e "Module name:      ${YELLOW}$MODULE_NAME${NC}"
echo ""

# Find all header files
HEADER_FILES=$(find "$SRC_DIR" -type f \( -name "*.hpp" -o -name "*.h" \) | sort)

if [ -z "$HEADER_FILES" ]; then
    echo -e "${RED}Error: No header files found in $SRC_DIR${NC}"
    exit 1
fi

# Change detection: check if rebuild is needed
OUTPUT_FILE="$OUTPUT_DIR/${MODULE_NAME}.so"
NEEDS_REBUILD=0

if [ $FORCE_REBUILD -eq 1 ]; then
    NEEDS_REBUILD=1
    echo -e "${YELLOW}Force rebuild requested${NC}"
elif [ ! -f "$OUTPUT_FILE" ]; then
    NEEDS_REBUILD=1
    echo -e "${YELLOW}Output file not found, building...${NC}"
else
    # Check if any header file is newer than the output
    OUTPUT_MTIME=$(stat -c %Y "$OUTPUT_FILE" 2>/dev/null || stat -f %m "$OUTPUT_FILE" 2>/dev/null)

    while IFS= read -r header_file; do
        HEADER_MTIME=$(stat -c %Y "$header_file" 2>/dev/null || stat -f %m "$header_file" 2>/dev/null)
        if [ "$HEADER_MTIME" -gt "$OUTPUT_MTIME" ]; then
            NEEDS_REBUILD=1
            rel_path=$(realpath --relative-to="$SRC_DIR" "$header_file")
            echo -e "${YELLOW}Source changed: $rel_path${NC}"
            break
        fi
    done <<< "$HEADER_FILES"

    if [ $NEEDS_REBUILD -eq 0 ]; then
        echo -e "${GREEN}✓ Up to date: ${MODULE_NAME}.so${NC}"
        echo -e "${BLUE}No source files changed since last build. Use --force to rebuild anyway.${NC}"
        exit 0
    fi
fi

echo ""
echo -e "${YELLOW}Scanning for classes...${NC}"

# Discover classes
declare -a CLASSES
declare -a HEADERS

while IFS= read -r header_file; do
    # Get relative path from SRC_DIR
    rel_path=$(realpath --relative-to="$SRC_DIR" "$header_file")

    # Check if file should be skipped entirely
    if grep -q "MIRROR_BRIDGE_SKIP_FILE" "$header_file" 2>/dev/null; then
        if [ $VERBOSE -eq 1 ]; then
            echo -e "${BLUE}  Skipping file: $rel_path (MIRROR_BRIDGE_SKIP_FILE)${NC}"
        fi
        continue
    fi

    # Extract class/struct definitions
    # Look for: struct ClassName / class ClassName
    # Skip if preceded by MIRROR_BRIDGE_SKIP comment

    # Read file content
    content=$(cat "$header_file")

    # Find all class/struct definitions
    # Pattern: (struct|class) followed by identifier
    while IFS= read -r line; do
        # Check if line contains class or struct definition
        if [[ "$line" =~ ^[[:space:]]*(struct|class)[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*) ]]; then
            class_name="${BASH_REMATCH[2]}"

            # Check if this is a forward declaration (ends with ;)
            if [[ "$line" =~ \;[[:space:]]*$ ]]; then
                continue
            fi

            # Check if previous lines contain MIRROR_BRIDGE_SKIP
            line_num=$(grep -n "^[[:space:]]*\(struct\|class\)[[:space:]]\+$class_name" "$header_file" | head -1 | cut -d: -f1)
            if [ -n "$line_num" ] && [ "$line_num" -gt 1 ]; then
                prev_line=$((line_num - 1))
                if sed -n "${prev_line}p" "$header_file" | grep -q "MIRROR_BRIDGE_SKIP"; then
                    if [ $VERBOSE -eq 1 ]; then
                        echo -e "${BLUE}  Skipping: $class_name (marked MIRROR_BRIDGE_SKIP)${NC}"
                    fi
                    continue
                fi
            fi

            # Add to list
            CLASSES+=("$class_name")
            HEADERS+=("$rel_path")
            echo -e "  ${GREEN}✓${NC} Found: $class_name in $rel_path"
        fi
    done < "$header_file"

done <<< "$HEADER_FILES"

# Check if any classes found
if [ ${#CLASSES[@]} -eq 0 ]; then
    echo -e "${RED}Error: No classes found in $SRC_DIR${NC}"
    echo -e "${YELLOW}Tip: Classes must be defined as 'struct ClassName' or 'class ClassName'${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}Discovered ${#CLASSES[@]} classes${NC}"
echo ""

# Generate binding file (use _binding.cpp suffix so mirror_bridge_build extracts correct module name)
GENERATED_FILE="$OUTPUT_DIR/${MODULE_NAME}_binding.cpp"
echo -e "${YELLOW}Generating binding file...${NC}"

cat > "$GENERATED_FILE" << EOF
// Auto-generated by mirror_bridge_auto
// Source: $SRC_DIR
// Generated: $(date)

#include "mirror_bridge.hpp"
EOF

# Add header includes (unique only)
declare -A included
for header in "${HEADERS[@]}"; do
    if [ -z "${included[$header]}" ]; then
        echo "#include \"$header\"" >> "$GENERATED_FILE"
        included[$header]=1
    fi
done

echo "" >> "$GENERATED_FILE"

# Generate module with all class bindings
echo "MIRROR_BRIDGE_MODULE($MODULE_NAME," >> "$GENERATED_FILE"

for i in "${!CLASSES[@]}"; do
    class_name="${CLASSES[$i]}"
    echo "    mirror_bridge::bind_class<$class_name>(m, \"$class_name\");" >> "$GENERATED_FILE"
done

echo ")" >> "$GENERATED_FILE"

echo -e "${GREEN}✓ Generated: $GENERATED_FILE${NC}"
echo ""

# Build using mirror_bridge_build
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_SCRIPT="$SCRIPT_DIR/mirror_bridge_build"

if [ ! -x "$BUILD_SCRIPT" ]; then
    echo -e "${RED}Error: mirror_bridge_build not found or not executable${NC}"
    exit 1
fi

# Build command with source directory as include path
BUILD_CMD="$BUILD_SCRIPT $GENERATED_FILE -I $SRC_DIR -o $OUTPUT_DIR"
if [ $VERBOSE -eq 1 ]; then
    BUILD_CMD="$BUILD_CMD -v"
fi

# Add PCH support if requested
if [ -n "$USE_PCH" ]; then
    if [ "$PCH_PATH" = "auto" ]; then
        # Auto-detect PCH in common locations
        for pch_candidate in \
            "build/mirror_bridge_pch.hpp.gch" \
            "mirror_bridge_pch.hpp.gch" \
            "$OUTPUT_DIR/mirror_bridge_pch.hpp.gch" \
            "$SCRIPT_DIR/build/mirror_bridge_pch.hpp.gch"
        do
            if [ -f "$pch_candidate" ]; then
                PCH_PATH="$pch_candidate"
                echo -e "${GREEN}✓ Found PCH: $PCH_PATH${NC}"
                break
            fi
        done

        if [ "$PCH_PATH" = "auto" ]; then
            echo -e "${YELLOW}Warning: No PCH found in common locations${NC}"
            echo -e "${YELLOW}Creating PCH now (one-time setup)...${NC}"
            mkdir -p "$OUTPUT_DIR"
            PCH_PATH="$OUTPUT_DIR/mirror_bridge_pch.hpp.gch"

            # Create PCH with same flags as will be used for compilation
            clang++ -std=c++2c -freflection -freflection-latest \
                -fPIC -stdlib=libc++ \
                $(python3-config --includes) \
                -O3 -DNDEBUG \
                -x c++-header "$SCRIPT_DIR/mirror_bridge_pch.hpp" \
                -o "$PCH_PATH" 2>&1 | grep -v "mixture of designated" || true

            if [ -f "$PCH_PATH" ]; then
                echo -e "${GREEN}✓ PCH created: $PCH_PATH${NC}"
            else
                echo -e "${RED}Error: Failed to create PCH${NC}"
                USE_PCH=""
            fi
        fi
    fi

    if [ -n "$USE_PCH" ]; then
        BUILD_CMD="$BUILD_CMD --use-pch $PCH_PATH"
    fi
fi

eval "$BUILD_CMD"

# Clean up generated file unless requested to keep
if [ $KEEP_GENERATED -eq 0 ]; then
    rm "$GENERATED_FILE"
    echo -e "${BLUE}Cleaned up generated file${NC}"
else
    echo -e "${BLUE}Generated file kept: $GENERATED_FILE${NC}"
fi

echo ""
echo -e "${GREEN}✓ Successfully auto-discovered and built: ${MODULE_NAME}.so${NC}"
echo -e "${GREEN}  Classes bound: ${#CLASSES[@]}${NC}"
echo ""
echo -e "${BLUE}Usage from Python:${NC}"
echo -e "  import sys"
echo -e "  sys.path.insert(0, '$OUTPUT_DIR')"
echo -e "  import $MODULE_NAME"
echo ""
echo -e "  # Classes available:"
for class_name in "${CLASSES[@]}"; do
    echo -e "  # - $class_name"
done
echo ""
