#!/bin/bash
# Mirror Bridge Generate - Generate and compile bindings from a config file
# Usage: mirror_bridge_generate bindings.mirror [options]

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default configuration
OUTPUT_DIR="build"
VERBOSE=0
KEEP_GENERATED=0

# Help message
show_help() {
    cat << EOF
Mirror Bridge Generate - Generate bindings from config file

Usage: mirror_bridge_generate <config_file> [options]

Options:
  -o, --output-dir DIR    Output directory for .so file (default: build/)
  -k, --keep-generated    Keep generated binding .cpp file
  -v, --verbose           Show compilation output
  -h, --help              Show this help message

Config File Format (.mirror):

  # Module configuration
  module: my_module
  include_dirs: src/, include/

  # Class bindings (ClassName: header_file [as PythonName])
  Calculator: calculator.hpp
  Vector3: vector3.hpp
  math::Complex: complex.hpp as Complex

Example:
  mirror_bridge_generate bindings.mirror -o build/

This generates: build/my_module.so

EOF
}

# Parse arguments
CONFIG_FILE=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -o|--output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -k|--keep-generated)
            KEEP_GENERATED=1
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -*)
            echo -e "${RED}Error: Unknown option $1${NC}"
            show_help
            exit 1
            ;;
        *)
            if [ -z "$CONFIG_FILE" ]; then
                CONFIG_FILE="$1"
            else
                echo -e "${RED}Error: Multiple config files specified${NC}"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate input
if [ -z "$CONFIG_FILE" ]; then
    echo -e "${RED}Error: No config file specified${NC}"
    show_help
    exit 1
fi

if [ ! -f "$CONFIG_FILE" ]; then
    echo -e "${RED}Error: File not found: $CONFIG_FILE${NC}"
    exit 1
fi

# Get absolute paths
CONFIG_FILE=$(realpath "$CONFIG_FILE")
CONFIG_DIR=$(dirname "$CONFIG_FILE")
OUTPUT_DIR=$(realpath "$OUTPUT_DIR")

mkdir -p "$OUTPUT_DIR"

echo -e "${BLUE}Mirror Bridge Generate${NC}"
echo -e "${BLUE}======================${NC}"
echo ""
echo -e "Config file: ${YELLOW}$CONFIG_FILE${NC}"
echo ""

# Parse config file
MODULE_NAME=""
INCLUDE_DIRS=()
declare -a CLASSES
declare -a HEADERS
declare -a PYTHON_NAMES

while IFS= read -r line; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue

    # Parse module name
    if [[ "$line" =~ ^module:[[:space:]]*(.+)$ ]]; then
        MODULE_NAME="${BASH_REMATCH[1]}"
        MODULE_NAME=$(echo "$MODULE_NAME" | xargs)  # Trim whitespace
        continue
    fi

    # Parse include directories
    if [[ "$line" =~ ^include_dirs:[[:space:]]*(.+)$ ]]; then
        IFS=',' read -ra DIRS <<< "${BASH_REMATCH[1]}"
        for dir in "${DIRS[@]}"; do
            dir=$(echo "$dir" | xargs)  # Trim whitespace
            if [ -n "$dir" ]; then
                INCLUDE_DIRS+=("$dir")
            fi
        done
        continue
    fi

    # Parse class bindings
    # Format: ClassName: header.hpp [as PythonName]
    if [[ "$line" =~ ^([^:]+):[[:space:]]*([^[:space:]]+)([[:space:]]+as[[:space:]]+(.+))?$ ]]; then
        class_name="${BASH_REMATCH[1]}"
        header_file="${BASH_REMATCH[2]}"
        python_name="${BASH_REMATCH[4]}"

        class_name=$(echo "$class_name" | xargs)
        header_file=$(echo "$header_file" | xargs)

        if [ -z "$python_name" ]; then
            # Extract simple name from namespaced class (e.g., math::Vector -> Vector)
            python_name=$(echo "$class_name" | sed 's/.*:://')
        else
            python_name=$(echo "$python_name" | xargs)
        fi

        CLASSES+=("$class_name")
        HEADERS+=("$header_file")
        PYTHON_NAMES+=("$python_name")
    fi
done < "$CONFIG_FILE"

# Validate parsed config
if [ -z "$MODULE_NAME" ]; then
    echo -e "${RED}Error: No 'module:' specified in config file${NC}"
    exit 1
fi

if [ ${#CLASSES[@]} -eq 0 ]; then
    echo -e "${RED}Error: No classes specified in config file${NC}"
    exit 1
fi

# Display configuration
echo -e "Module: ${YELLOW}$MODULE_NAME${NC}"
echo -e "Classes: ${YELLOW}${#CLASSES[@]}${NC}"
for i in "${!CLASSES[@]}"; do
    echo -e "  - ${CLASSES[$i]} (${HEADERS[$i]}) -> ${PYTHON_NAMES[$i]}"
done
echo ""

# Generate binding file
GENERATED_FILE="$OUTPUT_DIR/${MODULE_NAME}_binding.cpp"
echo -e "${YELLOW}Generating binding file...${NC}"

cat > "$GENERATED_FILE" << EOF
// Auto-generated by mirror_bridge_generate
// Config: $CONFIG_FILE
// Generated: $(date)

#include "mirror_bridge.hpp"
EOF

# Add header includes
for header in "${HEADERS[@]}"; do
    echo "#include \"$header\"" >> "$GENERATED_FILE"
done

echo "" >> "$GENERATED_FILE"

# Generate module with all class bindings
echo "MIRROR_BRIDGE_MODULE($MODULE_NAME," >> "$GENERATED_FILE"

for i in "${!CLASSES[@]}"; do
    class_name="${CLASSES[$i]}"
    python_name="${PYTHON_NAMES[$i]}"
    echo "    mirror_bridge::bind_class<$class_name>(m, \"$python_name\");" >> "$GENERATED_FILE"
done

echo ")" >> "$GENERATED_FILE"

echo -e "${GREEN}✓ Generated: $GENERATED_FILE${NC}"
echo ""

# Build using mirror_bridge_build
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_SCRIPT="$SCRIPT_DIR/mirror_bridge_build"

if [ ! -x "$BUILD_SCRIPT" ]; then
    echo -e "${RED}Error: mirror_bridge_build not found or not executable${NC}"
    exit 1
fi

# Construct include arguments
INCLUDE_ARGS=()
for dir in "${INCLUDE_DIRS[@]}"; do
    # Convert relative paths to absolute (relative to config dir)
    if [[ "$dir" != /* ]]; then
        dir="$CONFIG_DIR/$dir"
    fi
    INCLUDE_ARGS+=("-I")
    INCLUDE_ARGS+=("$dir")
done

# Add config directory to includes
INCLUDE_ARGS+=("-I")
INCLUDE_ARGS+=("$CONFIG_DIR")

# Build command
BUILD_CMD="$BUILD_SCRIPT $GENERATED_FILE ${INCLUDE_ARGS[@]} -o $OUTPUT_DIR"
if [ $VERBOSE -eq 1 ]; then
    BUILD_CMD="$BUILD_CMD -v"
fi

eval "$BUILD_CMD"

# Clean up generated file unless requested to keep
if [ $KEEP_GENERATED -eq 0 ]; then
    rm "$GENERATED_FILE"
    echo -e "${BLUE}Cleaned up generated file${NC}"
else
    echo -e "${BLUE}Generated file kept: $GENERATED_FILE${NC}"
fi

echo ""
echo -e "${GREEN}✓ Successfully generated and built: ${MODULE_NAME}.so${NC}"
echo ""
echo -e "${BLUE}Usage from Python:${NC}"
echo -e "  import sys"
echo -e "  sys.path.insert(0, '$OUTPUT_DIR')"
echo -e "  import $MODULE_NAME"
echo ""
